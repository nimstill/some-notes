从框架层面开始：backbone -> angular -> react
工具生态：grunt -> gulp -> webpack
语言：JavaScript 1.3 -> ECMA 5 -> ECMA 2015，CSS2.1 -> CSS3.0，XHTML -> HTML4.0 -> HTML5.0
Firefox OS （虽然它挂了）
桌面应用：NW.js -> Electron
出现了Node.js和Mongodb
服务端框架：Express -> koa
移动应用：PhoneGap -> Cordova | ionic -> React Native | weex
语法检查：jslint -> eslint
模块化：AMD | CMD -> Commonjs -> import export
语法增强：CoffeeScript -> Dart -> TypeScript

原型继承和类继承是两种认知模式，本质上都是为了抽象（复用代码）。相对于类，原型更初级且更灵活。因此当一个系统内没有太多关联的事物的时候，用原型明显比用类更灵活便捷。

原型继承和类继承是两种不同的认知模式，原型继承在对象不是很多的简单应用模型里比类继承更加灵活方便。然而JavaScript的原型继承在语法上有一个构造器额外调用的问题，我们只要通过 createObjWithoutConstructor 来延迟构造器的调用，就能解决这个问题。

    (function(global){"use strict"

      Function.prototype.extend = function(props){
        var Super = this; //父类构造函数

        //父类原型
        var TmpCls = function(){

        }
        TmpCls.prototype = Super.prototype;

        var superProto = new TmpCls();

        //父类构造器wrapper
        var _super = function(){
          return Super.apply(this, arguments);
        }

        var Cls = function(){
          if(props.constructor){
            //执行构造函数
            props.constructor.apply(this, arguments);
          }
          //绑定 this._super 的方法
          for(var i in Super.prototype){
            _super[i] = Super.prototype[i].bind(this);
          }
        }
        Cls.prototype = superProto;
        Cls.prototype._super = _super;

        //复制属性
        for(var i in props){
          if(i !== "constructor"){
            Cls.prototype[i] = props[i];
          }
        }  

        return Cls;
      }

      function Animal(name){
        this.name = name;
      }

      Animal.prototype.sayName = function(){
        console.log("My name is "+this.name);
      }

      var Programmer = Animal.extend({
        constructor: function(name){
          this._super(name);
        },
        sayName: function(){
          this._super.sayName(name);
        },
        program: function(){
          console.log("I\"m coding...");
        }
      });
      //测试我们的类
      var animal = new Animal("dummy"),
          akira = new Programmer("akira");
      animal.sayName();//输出 ‘My name is dummy’
      akira.sayName();//输出 ‘My name is akira’
      akira.program();//输出 ‘I"m coding...’

    })(this);


Virtual DOM 算法主要是实现上面步骤的三个函数：element，diff，patch。然后就可以实际的进行使用：

    // 1. 构建虚拟DOM
    var tree = el('div', {'id': 'container'}, [
        el('h1', {style: 'color: blue'}, ['simple virtal dom']),
        el('p', ['Hello, virtual-dom']),
        el('ul', [el('li')])
    ])

    // 2. 通过虚拟DOM构建真正的DOM
    var root = tree.render()
    document.body.appendChild(root)

    // 3. 生成新的虚拟DOM
    var newTree = el('div', {'id': 'container'}, [
        el('h1', {style: 'color: red'}, ['simple virtal dom']),
        el('p', ['Hello, virtual-dom']),
        el('ul', [el('li'), el('li')])
    ])

    // 4. 比较两棵虚拟DOM树的不同
    var patches = diff(tree, newTree)

    // 5. 在真正的DOM元素上应用变更
    patch(root, patches)


**github搜索hakimel。瑞典人、开源项目作者、专注css。我想你看完他的github,一定给你对css有新的认识**

没有人情可言
哎
好好加油，提升自己



    道阻且长，冰冻三尺非一日之寒；
    广泛地学习，有条件和能力的同学尽早地接触客户端开发，更多地了解服务端开发；
    前端大有可为，新技术的发明者大多不是老东西，老东西经验足但是历史包袱重；
    只在浏览器中思考必死无疑；
    像一位同学提到的，打好基础，offer 就有。学校里倒腾几年真的很难搞出什么大新闻，面试官也不会刻意为难你；
    测试测试测试，前端测试值得学习掌握，比如 e2e，这是一个机会：我能告诉你很多公司的前端测试都瞎 JB 点吗？
    学习一些函数式编程的思想，例如：lodash、Redux、RxJS；
    拿到 offer 只是开始不要嘚瑟。


仍需努力！

C# 作业

css中原生的@import 指令两大弊端：
1. 放在代码最前端。
2. 对性能不利。


2016.06.13
offer   get


2016.06.18  没过6级  终究是个遗憾·············
