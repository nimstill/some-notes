面试，哎，都是小破公司，还特高傲
大公司的人都会很和蔼，真的是技术越好，品德越好

打印论文
明天答辩
好好为自己的大学，做个结尾
---
加油！

///////双向数据绑定

 avalon使用Object.defineProperty及VBS实现属性监控, 这样用户修数据时,就能立即进入 事件总线系统(观察者模式),然后取得与这属性相关联的订阅者数组(换言之的密封舱,不像ng那样, 一个$scope对象就一个$$watcher数组).而一般情况下,VM中的某个属性在视图中也只会用到几个位置, 那么几个位置,就会生成几个绑定对象,都放在相应的订阅者数组中,每个订阅者数组都不会太长. 因此同步视图,不会因此遍历的数组过长而假死.因此ng在处理2000个指令的页面时就易出问题 (一个grid,往往有两三重循环,很容就飙到5000个指令),而avalon的密封舱方案是能撑到12000个指令

 react, 首先使用编译手段(jsx的虚拟DOM转换), 将这部分消耗能提前释放出去, 不过将字符串(jsx模板)转换为一个个JS对象,也占不了多少内存. 然后是数据发生变动时, 由于数据变动都是需要用setState方法,因此兼容性很好, 少了Object.defineProperty或wrapper的消耗,然后对应数据通过render转换成字符串,字符串再转换虚拟DOM树 先后虚拟DOM进行比较, 更新视图.

react是面向组件设计, 一个组件就是一个密封舱, 很少会对所有虚拟DOM进行比较, 由于强制使用单向流动, 减少每次变动需要的diff. 没有绑定对象与wrapper的内存占用高的问题.

react的流行，只是ng太难用了，当ng或其他MVVM改用虚拟DOM进行视图更新，这优势就不需要！

---
引自  司徒正美

使用脏检测的angular,要求对所有作用域对象进行diff,使用通知刷新函数进行视图更新. 页面上的指令越多,需要比较的数据越多(有循环, 需要乘以数组长度或对象键值对个数),可能用于循环时间过长导致页面假死

 avalon使用Object.defineProperty及VBS实现属性监控, 这样用户修数据时,就能立即进入 事件总线系统(观察者模式),然后取得与这属性相关联的订阅者数组(换言之的密封舱,不像ng那样, 一个$scope对象就一个$$watcher数组).而一般情况下,VM中的某个属性在视图中也只会用到几个位置, 那么几个位置,就会生成几个绑定对象,都放在相应的订阅者数组中,每个订阅者数组都不会太长. 因此同步视图,不会因此遍历的数组过长而假死.因此ng在处理2000个指令的页面时就易出问题 (一个grid,往往有两三重循环,很容就飙到5000个指令),而avalon的密封舱方案是能撑到12000个指令

 react, 首先使用编译手段(jsx的虚拟DOM转换), 将这部分消耗能提前释放出去, 不过将字符串(jsx模板)转换为一个个JS对象,也占不了多少内存. 然后是数据发生变动时, 由于数据变动都是需要用setState方法,因此兼容性很好, 少了Object.defineProperty或wrapper的消耗,然后对应数据通过render转换成字符串,字符串再转换虚拟DOM树 先后虚拟DOM进行比较, 更新视图.

react是面向组件设计, 一个组件就是一个密封舱, 很少会对所有虚拟DOM进行比较, 由于强制使用单向流动, 减少每次变动需要的diff. 没有绑定对象与wrapper的内存占用高的问题.

react的流行，只是ng太难用了，当ng或其他MVVM改用虚拟DOM进行视图更新，这优势就不需要！

---
引自  司徒正美